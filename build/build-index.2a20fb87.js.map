{"mappings":"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","sources":["dist/Randomiser/Randomisation.js"],"sourcesContent":["var mixedGameData = {};\nObject.entries(EMERALD_WARPS).forEach(e => mixedGameData[e[0]] = e[1]);\n\nvar remappingsData = {};\nvar isHeadless = true;\n\n// WarpList used by EmulationCoreHacks.js\nvar warpList = new Map();\n\nfunction getMapData() {\n    return mixedGameData;\n}\n\nfunction getRandomisationAlgorithm() {\n    return generateRandomMappings;\n}\n\nfunction getRandomisationConfig() {\n    let config = {};\n    config.hoennLevel = document.getElementById(\"hoennLevel\").value;\n    return config;\n}\n\nfunction getFlagData() {\n  return FLAG_DATA;\n}\n\nfunction mappingToWarps(mappingData) {\n    let mappedList = new Map();\n\n    mappingData.forEach(mapping => {\n        let from = mapping.trigger;\n        let to = mapping.target;\n        let toParts = to.split(\",\");\n        mappedList.set(from, new PKWarp(from, toParts[0], toParts[1], toParts[2], toParts[3], mapping.source));\n    });\n\n    return mappedList;\n}\n\nasync function mapWarps(seed) {\n\n    flagsState = {};\n    unaddedConditionalEdges = {};\n\n    let config = getRandomisationConfig();\n    let mapData = getFilteredData();\n    let flagData = getFlagData()\n    remappingsData = getRandomisationAlgorithm().apply(null, [seed, mapData, flagData, config]);\n    warpList = mappingToWarps(getAugmetedRemappingData(remappingsData));\n    updateHashDisplay();\n\n    if (typeof storageManager !== 'undefined') {\n      storageManager.persist(\"RANDOM_MAPPING\", new WarpListData(seed, config, warpList));\n    }\n}\n\nfunction generateRandomMappings(seed, mapData, flagData, config) {\n    \n    let rng = new RNG(getHash(seed));\n    let progressionState = initMappingGraph(mapData, isHeadless, new ProgressionState(flagData, config))\n\n    var root = getInitialWarp(config);\n\n    progressionState.unconnectedComponents = progressionState.unconnectedComponents.filter(a => !a.includes(root));\n\n    var moreWarpsToMap = true;\n    while(moreWarpsToMap) {\n        moreWarpsToMap = doNextMapping(rng, root, progressionState);\n        progressionState = updateProgressionState(progressionState, root);\n    }\n\n   return getBaseRemappingData();\n}\n\nfunction getInitialWarp(config) {\n  return KEY_LOCATION_DATA[\"OLDALE TOWN\"];\n}\n\nfunction filterIgnored(mapData) {\n    return new Map([...mapData].filter(k => !k[1].ignore));\n}\n\nfunction filterByConfig(usabledWarps, config) {\n    usabledWarps = new Map([...usabledWarps].filter(w => {\n        let filterLevel = null;\n        if (w[0][0] == \"E\") {\n            filterLevel = config.hoennLevel;\n        } else if (w[0][0] == \"F\") {\n            filterLevel = config.kantoLevel;\n        } else if (w[0][0] == \"C\") {\n            filterLevel = config.johtoLevel;\n        }\n\n        return usabledWarps.get(w[0]).level && (+usabledWarps.get(w[0]).level <= +filterLevel);\n    }));\n    return usabledWarps;\n}\n\nfunction filteGroupedNotMain(mapData) {\n    return new Map([...mapData].filter(k => k[1].groupMain || !k[1].grouped));\n} \n\nfunction toMapBank(s) { \n    let arr = s.split(\",\"); \n    return arr[0] + \",\" + arr[1] + \",\" + arr[2] \n}\n\nfunction ProgressionState(flagData, config) {\n  this.remainingConditionalEdges = new Set();\n  this.flags = new Set();\n  this.flagData = flagData;\n  this.config = config;\n  // Locations that may grant further progress\n  this.unmarkedLocations = new Map(Object.entries(flagData.LOCATIONS_TRIGGER));\n  this.unmarkedFlags = new Map(Object.entries(flagData.COMPOSITE_FLAGS));\n  // Locations that will not grant progress but should be included anyway\n  this.unmarkedKeyLocations = new Map(Object.entries(flagData.KEY_LOCATIONS))\n}\n\nProgressionState.prototype.makeFinalLocationsKey = function (config) {\n\n  let finalLocations = [];\n\n  switch(this.config.hoennLevel) {\n    case \"1\": finalLocations.push(HINTABLE_LOCATIONS[\"ROXANNE\"])      ; break;\n    case \"2\": finalLocations.push(HINTABLE_LOCATIONS[\"BRAWLY\"])       ; break;\n    case \"3\": finalLocations.push(HINTABLE_LOCATIONS[\"WATTSON\"])      ; break; \n    case \"4\": finalLocations.push(HINTABLE_LOCATIONS[\"FLANNERY\"])     ; break;\n    case \"5\": finalLocations.push(HINTABLE_LOCATIONS[\"NORMAN\"])       ; break;\n    case \"6\": finalLocations.push(HINTABLE_LOCATIONS[\"WINONA\"])       ; break;\n    case \"7\": finalLocations.push(HINTABLE_LOCATIONS[\"TATE AND LIZA\"]); break;\n    case \"8\": finalLocations.push(HINTABLE_LOCATIONS[\"JUAN\"])         ; break;\n    case \"9\": \n    case \"0\": \n    case \"10\": \n    default:\n      // E4 and upwards are key locations not progression anyway  \n      break;\n  }\n\n  finalLocations.forEach(l => {\n    if (this.unmarkedLocations.has(l)) {\n      this.unmarkedKeyLocations.set(l, this.unmarkedLocations.get(l))\n      this.unmarkedLocations.delete(l);\n    }\n  })\n\n}\n\n/** \n *  Warp data model\n */\nfunction WarpListData(seed, config, warpList) {\n  this.warpList = Array.from(warpList.entries());\n  this.seed = seed;\n  this.config = config;\n} \n\nfunction exportMapping() {\n  storageManager.find(\"RANDOM_MAPPING\").then(s => {\n      let data = JSON.stringify(s);\n      let file = new File([data], \"WarpMapping.json\", {type: \"application/json;charset=utf-8\"});\n      saveAs(file);\n  });\n}\n\nfunction importMapping() {\n  let file = this.files[0];\n\n  let reader = new FileReader();\n  reader.readAsText(file,'UTF-8');\n\n  reader.onload = readerEvent => {\n      let content = readerEvent.target.result;\n      let warpListData = JSON.parse(content);\n      updateWarpListData(warpListData);\n      storageManager.persist(\"RANDOM_MAPPING\", warpListData);\n   }\n}\n\nfunction updateWarpListData(warpListData) {\n  document.getElementById(\"input_seed_text\").value = warpListData.seed;\n\n  document.getElementById(\"hoennLevel\").value = warpListData.config.hoennLevel;\n  M.FormSelect.getInstance(document.getElementById(\"hoennLevel\"))._handleSelectChangeBound();\n\n  warpList = new Map(warpListData.warpList);\n  updateHashDisplay();\n}\n\nfunction updateHashDisplay() {\n  document.getElementById(\"hashText\").innerHTML = \"CHECK: \" + Math.abs(getHash(JSON.stringify(Array.from(warpList)))).toString(16).toUpperCase();\n}\n\n/**\n *  Warp Script model \n */\n function PKWarp(trigger, romCode, bank, map, warpNo, source) {\n    this.trigger = trigger;\n    this.toRomCode = romCode;\n    this.toBank = bank;\n    this.toMap = map;\n    this.toWarpNo = warpNo;\n    this.source = source;\n}\n\n/**\n *  SEEDED RNG MANAGEMENT\n */\n\nfunction getHash(input){\n    var hash = 0, len = input.length;\n    for (var i = 0; i < len; i++) {\n      hash  = ((hash << 5) - hash) + input.charCodeAt(i);\n      hash |= 0; // to 32bit integer\n    }\n    return hash;\n}\n\nfunction RNG(seed) {\n    // LCG using GCC's constants\n    this.m = 0x80000000; // 2**31;\n    this.a = 1103515245;\n    this.c = 12345;\n  \n    this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));\n}\nRNG.prototype.nextInt = function() {\n  this.state = (this.a * this.state + this.c) % this.m;\n  return this.state;\n}\nRNG.prototype.nextFloat = function() {\n  // returns in range [0,1]\n  return this.nextInt() / (this.m - 1);\n}\nRNG.prototype.nextRange = function(start, end) {\n  // returns in range [start, end): including start, excluding end\n  // can't modulu nextInt because of weak randomness in lower bits\n  var rangeSize = end - start;\n  var randomUnder1 = this.nextInt() / this.m;\n  return Math.abs(start + Math.floor(randomUnder1 * rangeSize));\n}\nRNG.prototype.choice = function(array) {\n  return array[this.nextRange(0, array.length)];\n}\n\n/**\n *  GRAPHING / CONNECTION MANAGEMENT\n */\n\n function ReigonNode(id) {\n    this.data = {};\n    this.data.id = id;\n    this.classes = 'reigon';\n}\n\nfunction AreaNode(node) {\n    this.data = {};\n    this.data.id = toMapBank(node[0]);\n    this.data.parent = toReigon(node[0]);\n    this.data.label = node[0] + \" (\" + node[1].name.split(\"-\")[0] + \"- \" + node[1].name.split(\"-\")[1].trim() + \")\";\n}\n\nfunction WarpNode(data) {\n    this.data = {};\n    this.data.id = data[0];\n    this.data.parent = toMapBank(data[0]);\n    this.data.label = data[1].name ? data[0] + data[1].name.split(\"-\")[2] : data[0] + \" (Unnamed)\";\n    this.classes = 'outline';\n    this.data.isWarp = true;\n    this.data.isMapped = false;\n    this.data.hasMultipleConnections = data[1].connections ? Object.values(data[1].connections).filter(n => n == true).length > 0 : false;\n}\n\nfunction FixedEdge(source, target) {\n    this.data = {};\n    this.data.id = source + \"->\" + target;\n    this.data.source = source;\n    this.data.target = target;\n    this.classes = 'fixed';\n}\n\nfunction CondidtionalEdge(source, target, condition) {\n  this.data = {};\n  this.data.id = source + \"->\" + target;\n  this.data.source = source;\n  this.data.target = target;\n  this.classes = 'conditional';\n  this.condition = condition;\n}\n\nfunction WarpEdge(source, target, count) {\n  this.data = {};\n  this.data.id = source + \"->\" + target + \"#\" + window.cy.getElementById(source + \"->\" + target).length;\n  this.data.source = source;\n  this.data.target = target;\n  this.data.isWarp = true;\n  this.classes = 'warp';\n}\n\nfunction getAugmetedRemappingData(remappingData) {\n\n  remappingData = addGroupedMappings(remappingData);\n  remappingData = addTriggerData(remappingData);\n\n  return remappingData;\n}\n\nfunction addGroupedMappings(remappingData) {\n  \n  let groupMappings = [];\n\n  remappingData.forEach(m => {\n    let groups = getMapData()[m.source].grouped;\n    if (groups) {\n      groups.forEach(g => {\n        groupMappings.push({source: g, target: m.target});\n      });\n    }\n  })\n\n  return [...remappingData, ...groupMappings];\n}\n\nfunction addTriggerData(remappingData) {\n\n  return remappingData.map(m => {\n    m.trigger = getMapData()[m.source].to;\n    return m;\n  });\n\n}\n\nfunction getBaseRemappingData() {\n  return cy.edges().filter(e => e.data().isWarp).map(e => { return {source: e.data().source, target: e.data().target} });\n}\n\nfunction getFilteredData() {\n    let warpIdData = new Map(Object.entries(getMapData()));\n    warpIdData = filterIgnored(warpIdData);\n    warpIdData = filteGroupedNotMain(warpIdData);\n    warpIdData = filterByConfig(warpIdData, getRandomisationConfig());\n    return warpIdData;\n}\n\nfunction toReigon(id) {\n  return 'HOENN'\n}\n\nfunction findAccessibleUnmappedNodes(cy, root) {\n  let nodeSet = new Set();\n  cy.elements().bfs({roots: cy.getElementById(root), directed: true, visit: (v, e, u, i, depth) => {\n    \n    if(!v.data().isMapped) {\n      nodeSet.add(v)\n    }\n\n  }});\n  return nodeSet;\n}\n\nfunction doNextMapping(rng, root, progressionState) {\n    let accessibleNodes = progressionState.cachedNodes ? progressionState.cachedNodes : findAccessibleUnmappedNodes(window.cy, root);\n    let inacessibleNodes = cy.nodes().not(accessibleNodes).filter(e => e.data().isWarp && !e.data().isMapped);\n    let inaccesibleFlagLocations = inacessibleNodes.filter(n => progressionState.unmarkedLocations.has(n.data().id));\n    let inaccesibleKeyLocations = inacessibleNodes.filter(n => progressionState.unmarkedLocations.has(n.data().id));\n\n    if(accessibleNodes.size == 0 && inacessibleNodes.length == 0) { \n      return false; \n    }\n\n    let warp1 = [...accessibleNodes][rng.nextRange(0, accessibleNodes.size - 1)];\n    accessibleNodes.delete(warp1);\n    \n    let warp2 = null;\n    let shouldCacheNodes = false;\n    let inacessibleHubs = inacessibleNodes.filter(e => e.degree(true) > 0);\n    if (progressionState.unconnectedComponents.length > 0) {\n\n      // Add a node from every component of the graph (with the assumption no warps are present but all flags are met)\n      let randomComponent = progressionState.unconnectedComponents[rng.nextRange(0, progressionState.unconnectedComponents.length - 1)];\n      let randomNodeIdFromComponent = randomComponent[rng.nextRange(0, randomComponent.length - 1)];\n\n      warp2 = cy.getElementById(randomNodeIdFromComponent);\n      progressionState.unconnectedComponents = progressionState.unconnectedComponents.filter(c => c != randomComponent);\n\n    } else if (inaccesibleFlagLocations.length > 0) { \n\n      // Add inacessible dead-ends that might allow flags givinb access to new locations\n      warp2 = inaccesibleFlagLocations[rng.nextRange(0, inaccesibleFlagLocations.length - 1)];\n\n    } else if (inacessibleHubs.length > 0) {\n\n      // Add any hubs that there is still no access to... I'm not sure there would even be any left...\n      inacessibleNodes = inacessibleNodes.filter(e => e.degree(true) > 0);\n      warp2 = inacessibleNodes[rng.nextRange(0, inacessibleNodes.length - 1)];\n\n    } else if (inaccesibleKeyLocations.length > 0) {\n\n      // Add key inacessible locations \n      warp2 = inaccesibleKeyLocations[rng.nextRange(0, inaccesibleKeyLocations.length - 1)];\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n    } else if (inacessibleNodes.length > 0) {\n\n      // Add other inacessible dead-ends \n      warp2 = inacessibleNodes[rng.nextRange(0, inacessibleNodes.length - 1)];\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n\n    } else if (accessibleNodes.size > 0) {\n\n      // map together nodes that are already accessible\n      warp2 = [...accessibleNodes][rng.nextRange(0, accessibleNodes.size - 1)];\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n\n    } else {\n      //console.warn(\"Unevenly matched warps. \" + warp1.data().id + \" had to map to itself\");\n      // warp2 = warp1\n\n      // if one warp is left hanging we connect it to altering cave from fire red\n      warp2 = cy.add(new WarpNode(['E,24,106,0', getMapData()[\"E,24,106,0\"]]));\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n\n    }\n\n    // Once it's only dead ends left we can cache which nodes are accessible from the root \n    if (shouldCacheNodes && !progressionState.cachedNodes) {\n        progressionState.cachedNodes = accessibleNodes;\n    }\n\n    if (!warp1) {\n      \n      if (accessibleNodes.size != 0) {\n        console.log(\"Some accessible nodes were left:\")\n        accessibleNodes.forEach(n => {\n          console.log(n.data().id)\n        })\n      } else {\n        console.log(\"All accesible nodes mapped\")\n      }\n\n      if (inacessibleNodes.size != 0) {\n        console.log(\"Some inaccessible nodes were left:\")\n        inacessibleNodes.forEach(n => {\n          console.log(n.data().id)\n        })\n\n        warp2.data().isMapped = true;\n        return false;\n\n      } else {\n        console.log(\"All inaccesible nodes mapped\")\n      }\n\n    }\n\n    window.cy.add(new WarpEdge(warp1.data().id, warp2.data().id))\n\n    if (warp1 != warp2) {\n          window.cy.add(new WarpEdge(warp2.data().id, warp1.data().id))\n    }\n    \n    warp1.data().isMapped = true;\n    warp2.data().isMapped = true;\n\n    return true;\n}\n\n\nfunction updateProgressionState(updateProgressionState, root) {\n\n  let currentNodes = new Set();\n  cy.elements().bfs({roots: cy.getElementById(root), directed: true, visit: (v, e, u, i, depth) => { \n    currentNodes.add(v.data().id) \n  }});\n\n  updateProgressionState.unmarkedLocations.forEach((name, location) => {\n    if (currentNodes.has(location)) {\n      updateProgressionState.unmarkedLocations.delete(location);\n      updateProgressionState.flags.add(name);\n    }\n  });\n\n  updateProgressionState.unmarkedFlags.forEach(n => {\n    if (n.condition.every(flag => updateProgressionState.flags.has(flag))) {\n      updateProgressionState.flags.add(n.flag);\n      updateProgressionState.unmarkedFlags.delete(n.flag)\n    }\n  });\n\n  let conditionalEdges = updateProgressionState.remainingConditionalEdges;\n  conditionalEdges.forEach(e => {\n    if (updateProgressionState.flags.has(e.condition)) {\n      if (cy.getElementById(e.data.target).length > 0 && cy.getElementById(e.data.source).length > 0) {\n        cy.add(e);\n      }\n      conditionalEdges.delete(e);\n    }\n  });\n\n  return updateProgressionState;\n}\n\nfunction initMappingGraph(mapData, isHeadless, progressionState) {\n\n  var cy = window.cy = cytoscape({\n      container: isHeadless ? null : document.getElementById('cy'),\n      headless: isHeadless,\n      styleEnabled: !isHeadless,\n      boxSelectionEnabled: false,\n      textureOnViewport: true,\n    \n      style: [\n        {\n          selector: 'node',\n          css: {\n            'content': 'data(id)',\n            'text-valign': 'center',\n            'text-halign': 'center'\n          }\n        },\n        {\n          selector: ':parent',\n          css: {\n            'text-valign': 'top',\n            'text-halign': 'center'      \n          },\n          style: {\n            'shape' : 'roundrectangle',\n          }\n        },\n        {\n          selector: 'edge',\n          css: {\n            'curve-style': 'bezier',\n            'target-arrow-shape': 'triangle'\n          }\n        },\n        {\n          'selector': 'node[label]',\n          'style': {\n            'label': 'data(label)',\n            'text-valign': 'bottom',\n            'text-halign': 'center'\n          }\n        },\n        {\n          selector: '.reigon',\n          css: {\n              'background-color': '#2f3138',\n              'color' : '#C0C0C0',\n              'font-size' : '5em',\n              \"text-valign\": \"top\"\n          },\n        },\n        {\n          selector: '.map-F',\n          css: {\n              'background-color': '#ffc0c3',\n              'color' : '#C0C0C0',\n              'font-size' : '2em'\n          }\n        },\n        {\n          selector: '.map-C',\n          css: {\n              'background-color': '#c0c3ff',\n              'color' : '#C0C0C0',\n              'font-size' : '2em'\n          }\n        },\n        {\n          selector: '.map-E',\n          css: {\n              'background-color': '#c3ffc0',\n              'color' : '#C0C0C0',\n              'font-size' : '2em'\n          }\n        },\n        {\n          selector: '.warp',\n          css: {\n            'line-color': '#f92411',\n            \"curve-style\": \"straight-triangle\",\n          }\n        },\n        {\n          selector: '.conditional',\n          css: {\n            'line-color': '#1911f9'\n          }\n        },\n        {\n          selector: '.fixed',\n          css: {\n            'opacity': '0.5'\n          }\n        }\n      ],\n    \n      elements: {\n        nodes: [],\n        edges: []\n      }\n    });\n\n\n    cy.add(new ReigonNode(\"KANTO\"));\n    cy.add(new ReigonNode(\"JOHTO\"));\n    cy.add(new ReigonNode(\"HOENN\"));\n\n    let data = [...mapData];\n\n    // Add the nodes\n    data.forEach(d => {\n\n      if (!cy.getElementById(toMapBank(d[0])).length) {\n          cy.add(new AreaNode(d)).addClass(\"map-\" + d[0][0]);\n      }\n\n      cy.add(new WarpNode(d));\n    })\n\n    // Add fixed edges\n    data.forEach(d => {\n\n      let connections = d[1].connections ? d[1].connections : {};\n\n      Object.entries(connections).forEach(entry => {\n\n        if (typeof entry[1] == 'string') {\n\n          // Conditional Connection\n          progressionState.remainingConditionalEdges.add(new CondidtionalEdge(d[0], entry[0], entry[1]));\n\n          // Temporarily add conditional edges in the graph so we can work out what areas will be connected in future\n          if (cy.getElementById(entry[0]).length > 0) {\n            cy.add(new CondidtionalEdge(d[0], entry[0], entry[1]))\n          }\n\n        } else {\n\n          // Fixed Connection       \n\n          // Only draw path if connection node is present in total list of warps\n          // i.e if I'm only doing warps to first gym, don't draw a connection to a gym 2 level warp \n          if (cy.getElementById(entry[0]).length > 0) {\n            cy.add(new FixedEdge(d[0], entry[0]))\n          }\n        }\n      });\n    });\n\n    // calculate future connected areas then remove all conditional edges from the network\n    progressionState.unconnectedComponents = cy.elements().components()\n                                                          .filter(e => e.size() > 1)\n                                                          .map(e => e.toArray().filter(n => n.group() == \"nodes\" && n.data().isWarp && n.data().hasMultipleConnections).map(p => p.data().id))\n                                                          .filter(arr => arr.length > 0);\n    progressionState.remainingConditionalEdges.forEach(node => cy.getElementById(node.data.id).remove());\n\n    cy.nodes().forEach(function(node){\n      node.css(\"width\", 80);\n      node.css(\"height\", 80);\n    });\n\n    if (!isHeadless) {\n        cy.layout({name: 'cose-bilkent', animationDuration: 1000, nodeDimensionsIncludeLabels: true}).run();\n    }\n\n    progressionState.makeFinalLocationsKey();\n    return progressionState;\n}\n\n/* HINTS */\nfunction getHint(location) {\n  let mapData = new Map(Object.entries(getMapData()));\n  let warp = warpList.get(mapData.get(location).to);\n  if (!warp) {\n    return \"NOT PRESENT\";\n  }\n  let info = mapData.get(warp.toRomCode + \",\" + warp.toBank + \",\" + warp.toMap + \",\" + warp.toWarpNo).name;\n  let hint = warp.toRomCode == \"E\" ? \"HOENN - \" : (warp.toRomCode == \"C\" ? \"JOHTO - \" : \"KANTO - \");\n  return hint + info.split(\"-\")[0].trim() + \" - \" + info.split(\"-\")[1].trim();\n}\n\nvar HINTABLE_LOCATIONS = {\n  \"ROXANNE\"          : \"E,11,3,0\"  ,\n  \"BRAWLY\"           : \"E,3,3,0\"   ,\n  \"WATTSON\"          : \"E,10,0,0\"  ,\n  \"FLANNERY\"         : \"E,4,1,0\"   ,\n  \"NORMAN\"           : \"E,8,1,0\"   ,\n  \"WINONA\"           : \"E,12,1,0\"  ,\n  \"TATE AND LIZA\"    : \"E,14,0,0\"  ,\n  \"JUAN\"             : \"E,15,0,0\"  , \n  \"E4 SIDNEY\"        : \"E,16,0,0\"  ,\n  \"E4 PHOEBE\"        : \"E,16,1,0\"  ,\n  \"E4 GLACIA\"        : \"E,16,2,0\"  ,\n  \"E4 DRAKE\"         : \"E,16,3,0\"  ,\n  \"CHAMPION WALLACE\" : \"E,16,4,0\"  ,\n  \"STEVEN\"           : \"E,24,107,0\",\n}\n"],"names":["mixedGameData","Object","entries","EMERALD_WARPS","forEach","e","remappingsData","isHeadless","warpList","Map","getMapData","getRandomisationAlgorithm","generateRandomMappings","getRandomisationConfig","config","hoennLevel","document","getElementById","value","getFlagData","FLAG_DATA","mappingToWarps","mappingData","mappedList","mapping","from","trigger","toParts","target","split","set","PKWarp","source","async","mapWarps","seed","flagsState","unaddedConditionalEdges","mapData","getFilteredData","flagData","apply","getAugmetedRemappingData","updateHashDisplay","storageManager","persist","WarpListData","rng","RNG","getHash","progressionState","initMappingGraph","ProgressionState","root","getInitialWarp","unconnectedComponents","filter","a","includes","moreWarpsToMap","doNextMapping","updateProgressionState","getBaseRemappingData","KEY_LOCATION_DATA","filterIgnored","k","ignore","filterByConfig","usabledWarps","w","filterLevel","kantoLevel","johtoLevel","get","level","filteGroupedNotMain","groupMain","grouped","toMapBank","s","arr","this","remainingConditionalEdges","Set","flags","unmarkedLocations","LOCATIONS_TRIGGER","unmarkedFlags","COMPOSITE_FLAGS","unmarkedKeyLocations","KEY_LOCATIONS","Array","exportMapping","find","then","data","JSON","stringify","file","File","type","saveAs","importMapping","files","reader","FileReader","readAsText","onload","readerEvent","content","result","warpListData","parse","updateWarpListData","M","FormSelect","getInstance","_handleSelectChangeBound","innerHTML","Math","abs","toString","toUpperCase","romCode","bank","map","warpNo","toRomCode","toBank","toMap","toWarpNo","input","hash","len","length","i","charCodeAt","m","c","state","floor","random","ReigonNode","id","classes","AreaNode","node","parent","toReigon","label","name","trim","WarpNode","isWarp","isMapped","hasMultipleConnections","connections","values","n","FixedEdge","CondidtionalEdge","condition","WarpEdge","count","window","cy","remappingData","addTriggerData","addGroupedMappings","groupMappings","groups","g","push","to","edges","warpIdData","findAccessibleUnmappedNodes","cy1","nodeSet","elements","bfs","roots","directed","visit","v","u","depth","add","accessibleNodes","cachedNodes","inacessibleNodes","nodes","not","inaccesibleFlagLocations","has","inaccesibleKeyLocations","size","warp1","nextRange","delete","warp2","shouldCacheNodes","inacessibleHubs","degree","randomComponent","randomNodeIdFromComponent","console","log","currentNodes","location","every","flag","conditionalEdges","cytoscape","container","headless","styleEnabled","boxSelectionEnabled","textureOnViewport","style","selector","css","shape","color","opacity","d","addClass","entry","components","toArray","group","p","remove","layout","animationDuration","nodeDimensionsIncludeLabels","run","makeFinalLocationsKey","getHint","warp","info","prototype","finalLocations","HINTABLE_LOCATIONS","l","nextInt","nextFloat","start","end","rangeSize","randomUnder1","choice","array","ROXANNE","BRAWLY","WATTSON","FLANNERY","NORMAN","WINONA","JUAN","STEVEN"],"version":3,"file":"build-index.2a20fb87.js.map"}